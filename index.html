<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<title>src/astar</title>
<link rel="stylesheet" type="text/css" href="nimdoc.out.css">

<script type="text/javascript" src="dochack.js"></script>

<script type="text/javascript">
function main() {
  var pragmaDots = document.getElementsByClassName("pragmadots");
  for (var i = 0; i < pragmaDots.length; i++) {
    pragmaDots[i].onclick = function(event) {
      // Hide tease
      event.target.parentNode.style.display = "none";
      // Show actual
      event.target.parentNode.nextElementSibling.style.display = "inline";
    }
  }

  function switchTheme(e) {
      if (e.target.checked) {
          document.documentElement.setAttribute('data-theme', 'dark');
          localStorage.setItem('theme', 'dark');
      } else {
          document.documentElement.setAttribute('data-theme', 'light');
          localStorage.setItem('theme', 'light');
      }
  }

  const toggleSwitch = document.querySelector('.theme-switch input[type="checkbox"]');
  if (toggleSwitch !== null) {
    toggleSwitch.addEventListener('change', switchTheme, false);
  }

  var currentTheme = localStorage.getItem('theme');
  if (!currentTheme && window.matchMedia('(prefers-color-scheme: dark)').matches) {
    currentTheme = 'dark';
  }
  if (currentTheme) {
    document.documentElement.setAttribute('data-theme', currentTheme);

    if (currentTheme === 'dark' && toggleSwitch !== null) {
      toggleSwitch.checked = true;
    }
  }
}

window.addEventListener('DOMContentLoaded', main);
</script>

</head>
<body>
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">src/astar</h1>
    <div class="row">
  <div class="three columns">
  <div class="theme-switch-wrapper">
    <label class="theme-switch" for="checkbox">
      <input type="checkbox" id="checkbox" />
      <div class="slider round"></div>
    </label>
    &nbsp;&nbsp;&nbsp; <em>Dark Mode</em>
  </div>
  <div id="global-links">
    <ul class="simple">
    <li>
      <a href="theindex.html">Index</a>
    </li>
    </ul>
  </div>
  <div id="searchInputDiv">
    Search: <input type="text" id="searchInput"
      onkeyup="search()" />
  </div>
  <div>
    Group by:
    <select onchange="groupBy(this.value)">
      <option value="section">Section</option>
      <option value="type">Type</option>
    </select>
  </div>
  <ul class="simple simple-toc" id="toc-list">
<li>
  <a class="reference reference-toplevel" href="#7" id="57">Types</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#Distance"
    title="Distance = int | float">Distance</a></li>
  <li><a class="reference" href="#Graph"
    title="Graph = concept g
    ## The graph being traversed.
    ## * `nieghbors`: Iterates over the neighbors of a node in the graph
    ## * `cost`: Returns the price for moving between two nodes
    var node: Node
    for neighbor in g.neighbors(node):
      typeof(neighbor) is Node
    cost(g, node, node) is Distance">Graph</a></li>
  <li><a class="reference" href="#Node"
    title="Node = concept n
    ## Represents a node stored within a graph.
    ## * `==`: Nodes must be comparable so we know when we reach the goal
    ## * `hash`: Nodes are used as keys in a table, so they need to be
    ##   hashable
    `==`(n, n) is bool
    hash(n) is Hash">Node</a></li>
  <li><a class="reference" href="#Point"
    title="Point = concept p
    ## An X/Y Coordinate. This isn't used by the A-Star algorithm itself,
    ## but by the built in heuristic procs.
    p.x is Distance
    p.y is Distance">Point</a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#12" id="62">Procs</a>
  <ul class="simple simple-toc-section">
      <ul class="simple nested-toc-section">asTheCrowFlies
      <li><a class="reference" href="#asTheCrowFlies%2CP%2CP"
    title="asTheCrowFlies[P: Point](node, goal: P): float">asTheCrowFlies[P: Point](node, goal: P): float</a></li>

  </ul>
  <ul class="simple nested-toc-section">chebyshev
      <li><a class="reference" href="#chebyshev%2CP%2CP"
    title="chebyshev[P: Point; D: Distance](node, goal: P): D">chebyshev[P: Point; D: Distance](node, goal: P): D</a></li>

  </ul>
  <ul class="simple nested-toc-section">manhattan
      <li><a class="reference" href="#manhattan%2CP%2CP"
    title="manhattan[P: Point; D: Distance](node, goal: P): D">manhattan[P: Point; D: Distance](node, goal: P): D</a></li>

  </ul>
  <ul class="simple nested-toc-section">onLineToGoal
      <li><a class="reference" href="#onLineToGoal%2CP%2CP%2CP"
    title="onLineToGoal[P: Point; D: Distance](node, start, goal: P): D">onLineToGoal[P: Point; D: Distance](node, start, goal: P): D</a></li>

  </ul>
  <ul class="simple nested-toc-section">straightLine
      <li><a class="reference" href="#straightLine%2CD%2CP%2COption%5BP%3A%20Point%5D"
    title="straightLine[P: Point; D: Distance](weight: D; node: P; grandparent: Option[P]): D">straightLine[P: Point; D: Distance](weight: D; node: P; grandparent: Option[P]): D</a></li>

  </ul>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#15" id="65">Iterators</a>
  <ul class="simple simple-toc-section">
      <ul class="simple nested-toc-section">path
      <li><a class="reference" href="#path.i%2CG%2CN%2CN"
    title="path[G: Graph; N: Node; D: Distance](graph: G; start, goal: N): N">path[G: Graph; N: Node; D: Distance](graph: G; start, goal: N): N</a></li>

  </ul>

  </ul>
</li>

</ul>

  </div>
  
  <div class="nine columns" id="content">
  <div id="tocRoot"></div>
  
  <p class="module-desc"><p>Classic A-Star path finding</p>
<p>For more information about A-Star itself, the folks over at Red Blob Games put together a very comprehensive introduction:</p>
<p><a class="reference external" href="http://www.redblobgames.com/pathfinding/a-star/introduction.html">http://www.redblobgames.com/pathfinding/a-star/introduction.html</a> </p>
</p>
  <div class="section" id="7">
<h1><a class="toc-backref" href="#7">Types</a></h1>
<dl class="item">
<div id="Distance">
<dt><pre><a href="astar.html#Distance"><span class="Identifier">Distance</span></a> <span class="Other">=</span> <span class="Identifier">int</span> <span class="Operator">|</span> <span class="Identifier">float</span></pre></dt>
<dd>

Distance is used for two things:<ol class="simple"><li>To measure cost of moving between nodes</li>
<li>To represent the heuristic that determines how close a point is to the goal</li>
</ol>


</dd>
</div>
<div id="Graph">
<dt><pre><a href="astar.html#Graph"><span class="Identifier">Graph</span></a> <span class="Other">=</span> <span class="Keyword">concept</span> <span class="Identifier">g</span>
    <span class="Comment">## The graph being traversed.</span>
    <span class="Comment">## * `nieghbors`: Iterates over the neighbors of a node in the graph</span>
    <span class="Comment">## * `cost`: Returns the price for moving between two nodes</span>
    <span class="Keyword">var</span> <span class="Identifier">node</span><span class="Other">:</span> <a href="astar.html#Node"><span class="Identifier">Node</span></a>
    <span class="Keyword">for</span> <span class="Identifier">neighbor</span> <span class="Keyword">in</span> <span class="Identifier">g</span><span class="Other">.</span><span class="Identifier">neighbors</span><span class="Other">(</span><span class="Identifier">node</span><span class="Other">)</span><span class="Other">:</span>
      <span class="Keyword">typeof</span><span class="Other">(</span><span class="Identifier">neighbor</span><span class="Other">)</span> <span class="Identifier">is</span> <a href="astar.html#Node"><span class="Identifier">Node</span></a>
    <span class="Identifier">cost</span><span class="Other">(</span><span class="Identifier">g</span><span class="Other">,</span> <span class="Identifier">node</span><span class="Other">,</span> <span class="Identifier">node</span><span class="Other">)</span> <span class="Identifier">is</span> <a href="astar.html#Distance"><span class="Identifier">Distance</span></a></pre></dt>
<dd>



</dd>
</div>
<div id="Node">
<dt><pre><a href="astar.html#Node"><span class="Identifier">Node</span></a> <span class="Other">=</span> <span class="Keyword">concept</span> <span class="Identifier">n</span>
    <span class="Comment">## Represents a node stored within a graph.</span>
    <span class="Comment">## * `==`: Nodes must be comparable so we know when we reach the goal</span>
    <span class="Comment">## * `hash`: Nodes are used as keys in a table, so they need to be</span>
    <span class="Comment">##   hashable</span>
    <span class="Other">`</span><span class="Operator">==</span><span class="Other">`</span><span class="Other">(</span><span class="Identifier">n</span><span class="Other">,</span> <span class="Identifier">n</span><span class="Other">)</span> <span class="Identifier">is</span> <span class="Identifier">bool</span>
    <span class="Identifier">hash</span><span class="Other">(</span><span class="Identifier">n</span><span class="Other">)</span> <span class="Identifier">is</span> <span class="Identifier">Hash</span></pre></dt>
<dd>



</dd>
</div>
<div id="Point">
<dt><pre><a href="astar.html#Point"><span class="Identifier">Point</span></a> <span class="Other">=</span> <span class="Keyword">concept</span> <span class="Identifier">p</span>
    <span class="Comment">## An X/Y Coordinate. This isn't used by the A-Star algorithm itself,</span>
    <span class="Comment">## but by the built in heuristic procs.</span>
    <span class="Identifier">p</span><span class="Other">.</span><span class="Identifier">x</span> <span class="Identifier">is</span> <a href="astar.html#Distance"><span class="Identifier">Distance</span></a>
    <span class="Identifier">p</span><span class="Other">.</span><span class="Identifier">y</span> <span class="Identifier">is</span> <a href="astar.html#Distance"><span class="Identifier">Distance</span></a></pre></dt>
<dd>



</dd>
</div>

</dl></div>
<div class="section" id="12">
<h1><a class="toc-backref" href="#12">Procs</a></h1>
<dl class="item">
<div id="asTheCrowFlies,P,P">
<dt><pre><span class="Keyword">proc</span> <a href="#asTheCrowFlies%2CP%2CP"><span class="Identifier">asTheCrowFlies</span></a><span class="Other">[</span><span class="Identifier">P</span><span class="Other">:</span> <a href="astar.html#Point"><span class="Identifier">Point</span></a><span class="Other">]</span><span class="Other">(</span><span class="Identifier">node</span><span class="Other">,</span> <span class="Identifier">goal</span><span class="Other">:</span> <span class="Identifier">P</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">float</span> {.<span class="Identifier">inline</span>.}</pre></dt>
<dd>

A convenience function that measures the exact distance between two points. This is meant to be used as the heuristic when creating a new <tt class="docutils literal"><span class="pre"><span class="Identifier">AStar</span></span></tt> instance.

</dd>
</div>
<div id="chebyshev,P,P">
<dt><pre><span class="Keyword">proc</span> <a href="#chebyshev%2CP%2CP"><span class="Identifier">chebyshev</span></a><span class="Other">[</span><span class="Identifier">P</span><span class="Other">:</span> <a href="astar.html#Point"><span class="Identifier">Point</span></a><span class="Other">;</span> <span class="Identifier">D</span><span class="Other">:</span> <a href="astar.html#Distance"><span class="Identifier">Distance</span></a><span class="Other">]</span><span class="Other">(</span><span class="Identifier">node</span><span class="Other">,</span> <span class="Identifier">goal</span><span class="Other">:</span> <span class="Identifier">P</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">D</span> {.<span class="Identifier">inline</span>.}</pre></dt>
<dd>

A convenience function that measures the chebyshev distance between two points. This is also known as the diagonal distance. This is meant to be used as the heuristic when creating a new <tt class="docutils literal"><span class="pre"><span class="Identifier">AStar</span></span></tt> instance.

</dd>
</div>
<div id="manhattan,P,P">
<dt><pre><span class="Keyword">proc</span> <a href="#manhattan%2CP%2CP"><span class="Identifier">manhattan</span></a><span class="Other">[</span><span class="Identifier">P</span><span class="Other">:</span> <a href="astar.html#Point"><span class="Identifier">Point</span></a><span class="Other">;</span> <span class="Identifier">D</span><span class="Other">:</span> <a href="astar.html#Distance"><span class="Identifier">Distance</span></a><span class="Other">]</span><span class="Other">(</span><span class="Identifier">node</span><span class="Other">,</span> <span class="Identifier">goal</span><span class="Other">:</span> <span class="Identifier">P</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">D</span> {.<span class="Identifier">inline</span>.}</pre></dt>
<dd>

A convenience function that measures the manhattan distance between two points. This is meant to be used as the heuristic when creating a new <tt class="docutils literal"><span class="pre"><span class="Identifier">AStar</span></span></tt> instance.

</dd>
</div>
<div id="onLineToGoal,P,P,P">
<dt><pre><span class="Keyword">proc</span> <a href="#onLineToGoal%2CP%2CP%2CP"><span class="Identifier">onLineToGoal</span></a><span class="Other">[</span><span class="Identifier">P</span><span class="Other">:</span> <a href="astar.html#Point"><span class="Identifier">Point</span></a><span class="Other">;</span> <span class="Identifier">D</span><span class="Other">:</span> <a href="astar.html#Distance"><span class="Identifier">Distance</span></a><span class="Other">]</span><span class="Other">(</span><span class="Identifier">node</span><span class="Other">,</span> <span class="Identifier">start</span><span class="Other">,</span> <span class="Identifier">goal</span><span class="Other">:</span> <span class="Identifier">P</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">D</span> {.<span class="Identifier">inline</span>.}</pre></dt>
<dd>

<p>Computes the cross-product between the start-to-goal vector and the current-point-to-goal vector. When these vectors don't line up, the result will be larger. This allows you to give preference to points that are along the direct line between the start and the goal.</p>
<p>For example, you could define a heuristic like this:</p>
<p><pre class="listing">
proc heuristic(grid: Grid, node, start, goal, parent: Point): float =
    return 1.5 * onLineToGoal[Point, float](node, start, goal) +
        asTheCrowFlies(node, goal)
</pre></p>


</dd>
</div>
<div id="straightLine,D,P,Option[P: Point]">
<dt><pre><span class="Keyword">proc</span> <a href="#straightLine%2CD%2CP%2COption%5BP%3A%20Point%5D"><span class="Identifier">straightLine</span></a><span class="Other">[</span><span class="Identifier">P</span><span class="Other">:</span> <a href="astar.html#Point"><span class="Identifier">Point</span></a><span class="Other">;</span> <span class="Identifier">D</span><span class="Other">:</span> <a href="astar.html#Distance"><span class="Identifier">Distance</span></a><span class="Other">]</span><span class="Other">(</span><span class="Identifier">weight</span><span class="Other">:</span> <span class="Identifier">D</span><span class="Other">;</span> <span class="Identifier">node</span><span class="Other">:</span> <span class="Identifier">P</span><span class="Other">;</span>
    <span class="Identifier">grandparent</span><span class="Other">:</span> <span class="Identifier">Option</span><span class="Other">[</span><span class="Identifier">P</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">D</span></pre></dt>
<dd>

<p>Returns the given weight if a node doesn't have any turns. Otherwise, returns <tt class="docutils literal"><span class="pre"><span class="DecNumber">1</span></span></tt>. You can multiply the result of a different heuristic to give preference to straight paths.</p>
<p>For example, you could define a heuristic like this:</p>
<p><pre class="listing">
proc heuristic(
    grid: StraightLineGrid,
    node, start, goal, parent: XY,
    grandparent: Option[XY]
): float =
    straightLine[XY, float](1.2, node, grandparent) *
        manhattan[XY, float](node, goal)
</pre></p>


</dd>
</div>

</dl></div>
<div class="section" id="15">
<h1><a class="toc-backref" href="#15">Iterators</a></h1>
<dl class="item">
<div id="path.i,G,N,N">
<dt><pre><span class="Keyword">iterator</span> <a href="#path.i%2CG%2CN%2CN"><span class="Identifier">path</span></a><span class="Other">[</span><span class="Identifier">G</span><span class="Other">:</span> <a href="astar.html#Graph"><span class="Identifier">Graph</span></a><span class="Other">;</span> <span class="Identifier">N</span><span class="Other">:</span> <a href="astar.html#Node"><span class="Identifier">Node</span></a><span class="Other">;</span> <span class="Identifier">D</span><span class="Other">:</span> <a href="astar.html#Distance"><span class="Identifier">Distance</span></a><span class="Other">]</span><span class="Other">(</span><span class="Identifier">graph</span><span class="Other">:</span> <span class="Identifier">G</span><span class="Other">;</span> <span class="Identifier">start</span><span class="Other">,</span> <span class="Identifier">goal</span><span class="Other">:</span> <span class="Identifier">N</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">N</span></pre></dt>
<dd>

Executes the A-Star algorithm and iterates over the nodes that connect the start and goal

</dd>
</div>

</dl></div>

  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small style="color: var(--hint);">Made with Nim. Generated: 2023-09-30 18:19:24 UTC</small>
      </div>
    </div>
  </div>
</div>

</body>
</html>
